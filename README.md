
# Minecraft AutoClicker

Left and right customizable autoclicker with clicking sounds and additional features, designed in C# WPF. It is also capable of working in other processes besides Minecraft. Simple to use and requiring no installation


##

Available for *Windows*

[![MIT License](https://img.shields.io/apm/l/atomic-design-ui.svg?)](https://github.com/git/git-scm.com/blob/main/MIT-LICENSE.txt) 
[![Downloads](https://camo.githubusercontent.com/3edaaa126f06a4650ce57b87ae315dff9226b137390e6172bc3e031102a08cee/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f646f776e6c6f6164732f647265616d6e6574746563682f647265616d74696d652f746f74616c3f6c6f676f3d676974687562266c6f676f436f6c6f723d7768697465)](https://github.com/ricardomelendezz/Minecraft-Autoclicker/releases/tag/release)


## Left AutoClicker

- Set Clicks per second (CPS)
- Set CPS bounds
- Set CPS Drop amount and probability
- Jitter Motion
- Blockhit (Minecraft)
- Inventory Refill (Minecraft)
- Break Blocks (Minecraft)
- Disable when inventory is open (Minecraft)
- Set Left Autoclicker Thread Priority

![App Screenshot](https://i.imgur.com/LKqM1zT.png)


## Left AutoClicker Sounds 

Mouse: Roccat Kain 100

- Normal
- Jitter
- Butterfly

![App Screenshot](https://i.imgur.com/3NV5oHd.png)


## Right AutoClicker

- Set clicks per second (CPS).
- Set the lower and higher bounds.
- Set CPS Drop amount and probability.
- Jitter motion
- Set Right Autoclicker Thread Priority.
![App Screenshot](https://i.imgur.com/A2l6s7c.png)


## Right AutoClicker Sounds

Mouse: Roccat Kain 100

- Normal Click Sounds
- Drag Click Sounds
- Breezily Click Sounds
- GodBridge Click Sounds
- TellyBridge Click Sounds
- Moonwalk Click Sounds

![App Screenshot](https://i.imgur.com/Obuqi95.png)

## AutoClicker status

Check whether left and right autoclicker are enabled; check if Minecraft is running; shows if program detected simulated click due to autoclicker and x and y axis of the cursor on the screen.

![App Screenshot](https://i.imgur.com/RRmBFPf.png)



## Minecraft Settings

Allows the user to change the name of the Minecraft client (Minecraft Client, Lunar Client, Badlion Client, etc.) and the inventory key used in-game.

![App Screenshot](https://i.imgur.com/eoC38VQ.png)


## UI Color Picker

Allows the user to change the color of the graphical interface.

![App Screenshot](https://i.imgur.com/XqfguBE.png)


## Simple Documentation

### Simulate delay between each click

CPS: Clicks per second  

1 second = 1000 ms

```

x cps ------ 1000 ms  
1 cps ------ y ms  

x (cps) = 1000 / y (ms)  
y (ms)  = 1000 / x (cps)  
```

**Upper and lower bounds example:**

    For 20 cps:

    x1 = 1000 / 20 = 50 ms

    For 25 cps:

    x2 = 1000 / 25 = 40 ms

    For 10 cps:

    x3 = 1000 / 10 = 100 ms

    lessMs = random(0, x1 - x2)  
    lessMs = random(0, 50 - 40)  
    lessMs = random(0, 10)  

    moreMs = random(0, x3 - x1)  
    moreMs = random(0, 100 - 50)  
    moreMs = random(0, 50)  


First simulation example:
```
ms = 50 - lessMs + moreMs  
ms = 50 - random(0, 10) + random(0, 50)  
ms = 50 - 7 + 23  
ms = 66 ms  

cps = 1000 / 66 = 15.15 cps
```
Second simulation example:
```
ms = 50 - lessMs + moreMs  
ms = 50 - random(0, 10) + random(0, 50)  
ms = 50 - 10 + 4  
ms = 44 ms  

cps = 1000 / 44 = 22.73 cps
```

**Note:**  
I did not explain the drop cps, but I believe 
it is clear from the code. Doing so would have
made the explanation longer, which is not the 
aim of this section. MilisecondsUtil.cs contains
the source code for further details.

## Random Number Generator Algorithm

**The Simple Way (for simplicity & practicality)**

The RNGCryptoServiceProvider, which is a component of the Crypto API in the BCL,
should be able to handle the task. Technically, it's still a pseudo-random number,
but the quality of "randomness" is substantially greater, making it suited for simple
cryptography applications, as the name suggests.

Compared to the Random class in the BCL, this class is far superior.
If you plot the numbers generated by Random, for example, on a graph,
you should be able to identify patterns, which is a strong indicator of weakness.
This is primarily owing to the algorithm's reliance on a fixed-size, seeded lookup database.

**The Tough Way (for high quality theoretical randomness)**

True random numbers can only be created if the seed for the random function comes
from a truly random physical input source. The scientific world is still debating
(and will likely continue to do so for an extended period of time) whether there
is anything physical and really random.

To obtain really random numbers, you must utilize natural phenomena, such as nuclear
disintegration and tiny temperature changes (CPU temperature is a rather stable source).
This is nevertheless far more complicated and requires additional gear. 

Note that if you need genuinely random numbers, you may use a site like Random.org,
which generates numbers with extremely high randomness/entropy (based on atmospheric
noise). Data is available for free download. This may still be unduly difficult
for your case, although providing information suited for scientific research and
other purposes.

```
However, generating actual random numbers takes time, and since we need
"random" numbers for our algorithm as quickly as possible, it is preferable
to utilize a pseudo random number generator.

According to Random.org, a pseudo random number generator is suitable for
simulation and modeling purposes (https://www.random.org/randomness/).
In this instance, it is preferable to utilize the RNGCryptoServiceProvider
class as opposed to the Random class, as stated above.
```

    Sources: 

    1. https://stackoverflow.com/questions/1234094/how-can-i-generate-truly-not-pseudo-random-numbers-with-c
    2. https://www.random.org/randomness/
    3. https://www.random.org/faq/

## Number of Threads

Your thread is sharing CPU Time with other threads. The Sleep will end
as soon as it is your turn again and the kernel notices the sleep time
has elapsed, so it is not that accurate. CPU load, process priorities, 
number of concurrent threads, even from other processes, will have effect upon it. 

For this reason, I did the following:

```
1. I've set the process priority of the application to high priority.

2. Implemented threads only for the algorithms
   that are critical for the program to perform its main function.

4. Set the priority of unimportant (but neccesary) threads to low priority.

5. Included checkboxes (left clicker, right clicker, color picker) to allow
   users to start a thread only when necessary, preventing unneeded threads
   from influencing the performance of other threads, and threads are terminated
   when checkboxes are unchecked after being checked.
```
## Thread Sleep Latency Problem

Giving up CPU and then getting it back is _expensive_. 
According to [this article](http://www.tldp.org/HOWTO/IO-Port-Programming-4.html),
scheduler latency could be anywhere between 10-30ms on Linux. So if you need
to sleep less than 10ms with high precision then you need to use special
OS specific APIs. The usual C# Thread.Sleep() is not high resolution sleep. 

According to Mark Gearing's answer in StackOverflow, the delay is consistent,
exactly 15.625 ms because it looks like Windows timers have a granularity
of 1/64th of a second. If you need better than that then I feel your pain,
but that's the framework you have to fit within.
(Windows isn't a hard real-time OS and doesn't claim to be). 

And at least in my pc it's the same cause if I try to set 100 cps,
I always get around 33 cps but other answers and questions on stack overflow
suggest that it's actually between 1 - 16 ms or 5 - 16 ms.

If I try to set 100 cps, I always get as max 33 cps,
but other answers and questions on StackOverflow
indicate that it's actually between 1 and 16 milliseconds
or 5 and 16 milliseconds.

    Sources:
    1. https://stackoverflow.com/questions/1303667/how-accurate-is-thread-sleeptimespan
    2. https://stackoverflow.com/questions/65851208/significant-overhead-for-stdthis-threadsleep-in-msvc-16-8-4

**Simple Workaround**

We can attempt to generate an approximation by subtracting a random number
between 1 and 15 milliseconds from the milliseconds derived from the main equation.

Pseudocode:

    Thread.Sleep(ms - random(1, 15) > 0)

Getting the cps limit

	ms - 15 > 0
	
	(500 / cps) - 15 > 0
	
	The critical point is: 
	
	500 / cps - 15 = 0
	500 / cps = 15
	cps = 33.33


So, actually the limit can be up to 31 cps, since (500 / 31 cps = 16 ms)

Therefore, any cps value less than or equal to 31 cps should be safe as this ensures that our application will not crash as a result of passing a negative integer value to the Thread. Sleep() method, as we subtract a random value between 1 and 15 milliseconds from the ms delay due to latency to obtain a somewhat accurate delay (ms).

Thread.Sleep is not intended to be used for precision waking. Really, windows architecture itself is not intended for this kind of thing since it's not a real-time OS. 

Our main algorithms, left clicker and right clicker, depends on Thread sleep.



## License

[MIT](https://choosealicense.com/licenses/mit/)

