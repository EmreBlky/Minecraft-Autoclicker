
# Minecraft AutoClicker

Left and right customizable autoclicker with clicking sounds and additional features, designed in C# WPF. It is also capable of working in other processes besides Minecraft. Simple to use and requiring no installation


##

Available for *Windows*

[![MIT License](https://img.shields.io/apm/l/atomic-design-ui.svg?)](https://github.com/git/git-scm.com/blob/main/MIT-LICENSE.txt) 
[![Downloads](https://camo.githubusercontent.com/3edaaa126f06a4650ce57b87ae315dff9226b137390e6172bc3e031102a08cee/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f646f776e6c6f6164732f647265616d6e6574746563682f647265616d74696d652f746f74616c3f6c6f676f3d676974687562266c6f676f436f6c6f723d7768697465)](https://github.com/ricardomelendezz/Minecraft-Autoclicker/releases/tag/release)


## Left AutoClicker

- Set Clicks per second (CPS)
- Set CPS bounds
- Set CPS Drop amount and probability
- Jitter Motion
- Blockhit (Minecraft)
- Inventory Refill (Minecraft)
- Break Blocks (Minecraft)
- Disable when inventory is open (Minecraft)
- Set Left Autoclicker Thread Priority

![App Screenshot](https://i.imgur.com/LKqM1zT.png)


## Left AutoClicker Sounds 

Mouse: Roccat Kain 100

- Normal
- Jitter
- Butterfly

![App Screenshot](https://i.imgur.com/3NV5oHd.png)


## Right AutoClicker

- Set clicks per second (CPS).
- Set the lower and higher bounds.
- Set CPS Drop amount and probability.
- Jitter motion
- Set Right Autoclicker Thread Priority.
![App Screenshot](https://i.imgur.com/A2l6s7c.png)


## Right AutoClicker Sounds

Mouse: Roccat Kain 100

- Normal Click Sounds
- Drag Click Sounds
- Breezily Click Sounds
- GodBridge Click Sounds
- TellyBridge Click Sounds
- Moonwalk Click Sounds

![App Screenshot](https://i.imgur.com/Obuqi95.png)

## AutoClicker status

Check whether left and right autoclicker are enabled; check if Minecraft is running; shows if program detected simulated click due to autoclicker and x and y axis of the cursor on the screen.

![App Screenshot](https://i.imgur.com/RRmBFPf.png)



## Minecraft Settings

Allows the user to change the name of the Minecraft client (Minecraft Client, Lunar Client, Badlion Client, etc.) and the inventory key used in-game.

![App Screenshot](https://i.imgur.com/eoC38VQ.png)


## UI Color Picker

Allows the user to change the color of the graphical interface.

![App Screenshot](https://i.imgur.com/XqfguBE.png)


## Simple Documentation

### Simulate delay between each click

CPS: Clicks per second  

1 second = 1000 ms

```

x cps ------ 1000 ms  
1 cps ------ y ms  

x (cps) = 1000 / y (ms)  
y (ms)  = 1000 / x (cps)  
```

**Upper and lower bounds example:**

    For 20 cps:

    x1 = 1000 / 20 = 50 ms

    For 25 cps:

    x2 = 1000 / 25 = 40 ms

    For 10 cps:

    x3 = 1000 / 10 = 100 ms

    lessMs = random(0, x1 - x2)  
    lessMs = random(0, 50 - 40)  
    lessMs = random(0, 10)  

    moreMs = random(0, x3 - x1)  
    moreMs = random(0, 100 - 50)  
    moreMs = random(0, 50)  


First simulation example:
```
ms = 50 - lessMs + moreMs  
ms = 50 - random(0, 10) + random(0, 50)  
ms = 50 - 7 + 23  
ms = 66 ms  

cps = 1000 / 66 = 15.15 cps
```
Second simulation example:
```
ms = 50 - lessMs + moreMs  
ms = 50 - random(0, 10) + random(0, 50)  
ms = 50 - 10 + 4  
ms = 44 ms  

cps = 1000 / 44 = 22.73 cps
```

**Note:**  
I did not explain the drop cps, but I believe 
it is clear from the code. Doing so would have
made the explanation longer, which is not the 
aim of this section. MilisecondsUtil.cs contains
the source code for further details.

## Random Number Generator Algorithm

**The Simple Way (for simplicity & practicality)**

The RNGCryptoServiceProvider, which is a component of the Crypto API in the BCL,
should be able to handle the task. Technically, it's still a pseudo-random number,
but the quality of "randomness" is substantially greater, making it suited for simple
cryptography applications, as the name suggests.

Compared to the Random class in the BCL, this class is far superior.
If you plot the numbers generated by Random, for example, on a graph,
you should be able to identify patterns, which is a strong indicator of weakness.
This is primarily owing to the algorithm's reliance on a fixed-size, seeded lookup database.

**The Tough Way (for high quality theoretical randomness)**

True random numbers can only be created if the seed for the random function comes
from a truly random physical input source. The scientific world is still debating
(and will likely continue to do so for an extended period of time) whether there
is anything physical and really random.

To obtain really random numbers, you must utilize natural phenomena, such as nuclear
disintegration and tiny temperature changes (CPU temperature is a rather stable source).
This is nevertheless far more complicated and requires additional gear. 

Note that if you need genuinely random numbers, you may use a site like Random.org,
which generates numbers with extremely high randomness/entropy (based on atmospheric
noise). Data is available for free download. This may still be unduly difficult
for your case, although providing information suited for scientific research and
other purposes.

```
However, generating actual random numbers takes time, and since we need
"random" numbers for our algorithm as quickly as possible, it is preferable
to utilize a pseudo random number generator.

According to Random.org, a pseudo random number generator is suitable for
simulation and modeling purposes (https://www.random.org/randomness/).
In this instance, it is preferable to utilize the RNGCryptoServiceProvider
class as opposed to the Random class, as stated above.
```

    Sources: 

    1. https://stackoverflow.com/questions/1234094/how-can-i-generate-truly-not-pseudo-random-numbers-with-c
    2. https://www.random.org/randomness/
    3. https://www.random.org/faq/

## Number of Threads

Your thread is sharing CPU Time with other threads. The Sleep will end
as soon as it is your turn again and the kernel notices the sleep time
has elapsed, so it is not that accurate. CPU load, process priorities, 
number of concurrent threads, even from other processes, will have effect upon it. 

For this reason, I did the following:

```
1. I've set the process priority of the application to high priority.

2. Implemented threads only for the algorithms
   that are critical for the program to perform its main function.

4. Set the priority of unimportant (but neccesary) threads to low priority.

5. Included checkboxes (left clicker, right clicker, color picker) to allow
   users to start a thread only when necessary, preventing unneeded threads
   from influencing the performance of other threads, and threads are terminated
   when checkboxes are unchecked after being checked.
```
## Window's Timer Resolution and Thread Sleep Problem

Giving up CPU and then getting it back is _expensive_. 
According to [this article](http://www.tldp.org/HOWTO/IO-Port-Programming-4.html),
scheduler latency could be anywhere between 10-30ms on Linux. So if you need
to sleep less than 10ms with high precision then you need to use special
OS specific APIs. The usual Thread sleep is not high resolution sleep. 

The system timer resolution determines how frequently Windows performs two main actions:

Update the timer tick count if a full tick has elapsed.
Check whether a scheduled timer object has expired.
A timer tick is a notion of elapsed time that Windows uses to track the time of day and
thread quantum times. By default, the clock interrupt and timer tick are the same, but
Windows or an application can change the clock interrupt period.

```
The default timer resolution on Windows is (1000/64) 15.625 milliseconds (ms). 
Some applications reduce this to 1 ms, which reduces the battery run time on mobile systems by as much as 25 percent.
Source: https://stackoverflow.com/questions/3744032/why-are-net-timers-limited-to-15-ms-resolution
```

## Thread Sleep Problem

Our primary algorithms (left clicker and right clicker) are dependent on the standard timer resolution because it influences the timers and threads.
To achieve 500 cps, for instance, the delay (ms) between each click must be 1ms.
Due to the timer's resolution of 15,625 milliseconds, it will not be possible to set this delay to 1 millisecond; instead, 15,625 milliseconds will be assigned.

Using our principal equation given above:

```
cps = 500 / ms  
cps = 500 / 15.625  
cps = 32 cps  
```

If the standard timer resolution of 15.625 ms is not changed to 1 ms, the maximum cps that can be achieved is 32.


## Timer Resolution from 15.625 ms to 0.5 - 1 ms Workarounds

The timer resolution is determined by the heartbeat of the system. This is typically set to 64 beats per second, or 15,625 milliseconds.
On newer platforms, it is possible to modify these system-wide settings to achieve timer resolutions of 1 ms or even 0.5 ms:

1. Using the multimedia timer interface for a 1 millisecond resolution:

The multimedia timer interface can provide resolutions as low as 1 millisecond. 
For more information on timeBeginPeriod, see About Multimedia Timers (MSDN), Obtaining and Setting Timer Resolution (MSDN), and this answer.
Note: When finished, don't forget to call timeEndPeriod to return to the default timer resolution.

** Code example: **
```
	public static class WinApi
	{
	    /// <summary>TimeBeginPeriod(). See the Windows API documentation for details.</summary>
	
	    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Interoperability", "CA1401:PInvokesShouldNotBeVisible"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage"), SuppressUnmanagedCodeSecurity]
	    [DllImport("winmm.dll", EntryPoint="timeBeginPeriod", SetLastError=true)]
	
	    public static extern uint TimeBeginPeriod(uint uMilliseconds);
	
	    /// <summary>TimeEndPeriod(). See the Windows API documentation for details.</summary>
	
	    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Interoperability", "CA1401:PInvokesShouldNotBeVisible"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage"), SuppressUnmanagedCodeSecurity]
	    [DllImport("winmm.dll", EntryPoint="timeEndPeriod", SetLastError=true)]
	
	    public static extern uint TimeEndPeriod(uint uMilliseconds);
	    
	}
	
	public void foo()
	{
		WinApi.TimeBeginPeriod(1); // Set Sleep resolution to 1ms
		
		//
		// your code
		//
		
		WinApi.TimeEndPeriod(1); // Clears previously set minimum timer resolution.
	}
```		

2. Going to 0.5 ms resolution:

Using the hidden API NtSetTimerResolution, you can achieve a resolution of 0.5 ms.
NtSetTimerResolution is exported by NTDLL.DLL, the native Windows NT library.
How to set the timer resolution to 0.5ms can be found on MSDN. However, the actual
achievable resolution depends on the underlying hardware.
Modern hardware supports a resolution of 0.5 milliseconds.
Inside Windows NT High Resolution Timers offers additional information.
An invocation of NtQueryTimerResolution returns the supported resolutions.

** Code example: **

```
	public static class WinApi
	{
	    [DllImport("ntdll.dll", EntryPoint = "NtSetTimerResolution")]
	
	    public static extern void NtSetTimerResolution(uint DesiredResolution, bool SetResolution, ref uint CurrentResolution);
	}
	
	public void foo()
	{
		uint currentRes = 0;
           WinApi.NtSetTimerResolution(5000, true, ref currentRes); // Sets the timer resolution to 0.5ms.
           
           // your code
           
           WinApi.NtSetTimerResolution(5000, false, ref currentRes); // Clears previously set minimum timer resolution.
	}
```

Using the boolean value SetResolution, the functionality of NtSetTImerResolution is mapped to the functions timeBeginPeriod
and timeEndPeriod (see Inside Windows NT High Resolution Timers for more details about the scheme and all its implications).
The multimedia suite limits the resolution to milliseconds, whereas NtSetTimerResolution permits sub-millisecond settings.

```
Source: https://stackoverflow.com/questions/3744032/why-are-net-timers-limited-to-15-ms-resolution
```


## Timer Resolution and Windows 11 Problem

Beginning with Windows 11, if a window-owning process is fully obscured,
minimized, or otherwise invisible or inaudible to the end user, Windows does not guarantee
a higher resolution than the system's default resolution.

## Timer Resolution and Windows 11 Workaround

If the user does not require the application window to be
in the foreground while using the application, as in this case where the 
foreground window will be the Minecraft window and the application window will 
be in the background, we can play a silence sound in a separate thread inside 
a while loop for as long as the application is running  or when one of the mouse
buttons is pressed to negate one of the conditions that prevent the modified timer resolution.

This can be implemented as follows:

```
{
    System.Media.SoundPlayer player = new System.Media.SoundPlayer(Properties.Resources.silence_sound);
    player.Play();
}
```

The sound of silence can be generated using Audacity.

## License

[MIT](https://choosealicense.com/licenses/mit/)

